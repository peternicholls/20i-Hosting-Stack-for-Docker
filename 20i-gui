#!/bin/bash

# 20i Stack GUI Manager
# A simple dialog-based interface for managing 20i Docker stacks
# Usage: 20i-gui

STACK_HOME="${STACK_HOME:-$HOME/docker/20i-stack}"
STACK_FILE="$STACK_HOME/docker-compose.yml"

# Check if stack directory exists
if [[ ! -f "$STACK_FILE" ]]; then
    echo "‚ùå Error: Docker compose file not found at $STACK_FILE"
    exit 1
fi

# Function to show a menu using dialog or fallback to simple prompts
show_menu() {
    if command -v dialog >/dev/null 2>&1; then
        # Use dialog if available (prettier interface)
        dialog --clear --title "20i Stack Manager" \
               --menu "Choose an action:" 15 50 5 \
               1 "üöÄ Start Stack (current directory)" \
               2 "üõë Stop Stack" \
               3 "üîÅ Restart Stack" \
               4 "üìä View Status" \
               5 "üìã View Logs" 2>/tmp/menu_choice
        
        if [[ $? -eq 0 ]]; then
            choice=$(cat /tmp/menu_choice)
            rm -f /tmp/menu_choice
        else
            clear
            exit 0
        fi
    else
        # Fallback to simple text menu
        echo "üöÄ 20i Stack Manager"
        echo "=================="
        echo "1) üöÄ Start Stack (current directory)"
        echo "2) üõë Stop Stack"
        echo "3) ÔøΩ Restart Stack"
        echo "4) üìä View Status"
        echo "5) üìã View Logs"
        echo "q) Quit"
        echo
        read -p "Choose an option: " choice
        
        if [[ "$choice" == "q" ]]; then
            exit 0
        fi
    fi
    
    case $choice in
        1) start_stack ;;
        2) stop_stack ;;
        3) restart_stack ;;
        4) view_status ;;
        5) view_logs ;;
        *) echo "‚ùå Invalid choice"; exit 1 ;;
    esac
}

# Function to sanitize project names for Docker Compose
sanitize_project_name() {
    local name="$1"
    # Lowercase
    name="$(echo "$name" | tr '[:upper:]' '[:lower:]')"
    # Replace any sequence of invalid chars with single hyphen
    name="$(echo "$name" | sed -E 's/[^a-z0-9]+/-/g')"
    # Collapse consecutive hyphens/underscores into single hyphen
    name="$(echo "$name" | sed -E 's/[-_]+/-/g')"
    # Trim leading/trailing hyphens using parameter expansion
    name="${name##-}"
    name="${name%%-}"
    # Ensure it starts with a letter or number
    if [[ ! "$name" =~ ^[a-z0-9] ]]; then
        name="p${name}"
    fi
    # Fallback
    if [[ -z "$name" ]]; then
        name="project"
    fi
    echo "$name"
}

# Function to get process info for a listening TCP port (macOS-compatible)
get_port_info() {
    local p="$1"
    # lsof prints a header; we want the first listening process entry
    # Format: COMMAND PID ...
    local info
    info=$(lsof -nP -iTCP:"$p" -sTCP:LISTEN 2>/dev/null | awk 'NR==2{printf "%s (pid %s)", $1, $2}')
    echo "$info"
}

# Function to show port availability for some common ranges
show_port_choices() {
    local ranges=("80-90" "8080-8090" "3000-3010")
    echo "üåê Port availability (free / in-use):"
    for r in "${ranges[@]}"; do
        IFS=- read -r start end <<< "$r"
        echo " Range ${start}-${end}:"
        for ((p=start; p<=end; p++)); do
            local info
            info=$(get_port_info "$p")
            if [[ -n "$info" ]]; then
                printf "  %3d: in use - %s\n" "$p" "$info"
            else
                printf "  %3d: free\n" "$p"
            fi
        done
    done
    echo
}

# Find a free port from common ranges (falls back to high ephemeral ports)
find_free_port() {
    local ranges=("80-90" "8080-8090" "3000-3010")
    for r in "${ranges[@]}"; do
        IFS=- read -r start end <<< "$r"
        for ((p=start; p<=end; p++)); do
            if [[ -z "$(get_port_info "$p")" ]]; then
                echo "$p"; return 0
            fi
        done
    done
    # Fallback: pick a random ephemeral port (49152‚Äì65535) that's free
    while true; do
        p=$(( (RANDOM % 16384) + 49152 ))
        if [[ -z "$(get_port_info "$p")" ]]; then
            echo "$p"; return 0
        fi
    done
}

# Function to start stack
start_stack() {
    local PROJECT_DIR="$(pwd)"
    local PROJECT_NAME="$(basename "$PROJECT_DIR")"
    local SAFE_PROJECT_NAME="$(sanitize_project_name "$PROJECT_NAME")"
    
    echo "üöÄ Starting 20i stack for project: $PROJECT_NAME"
    if [[ "$SAFE_PROJECT_NAME" != "$PROJECT_NAME" ]]; then
        echo "üìõ Normalized project name: $SAFE_PROJECT_NAME"
    fi
    echo "üìÅ Code directory: $PROJECT_DIR"
    
    # Check for local overrides
    if [[ -f .20i-local ]]; then
        echo "üìù Loading local configuration from .20i-local"
        source .20i-local
    fi
    
    # Set environment variables
    export COMPOSE_PROJECT_NAME="$SAFE_PROJECT_NAME"
    export CODE_DIR="$PROJECT_DIR"
    
    # Ask for custom port if not set
    if [[ -z "$HOST_PORT" ]]; then
        show_port_choices
        echo "‚ÑπÔ∏è  Leave blank to auto-select a free port from the shown ranges."
        while true; do
            read -p "üåê Web port (default 80 ‚Äî leave blank to auto-pick): " input_port
            if [[ -z "$input_port" ]]; then
                HOST_PORT="$(find_free_port)"
                echo "‚ÑπÔ∏è  Auto-selected free port: $HOST_PORT"
                break
            fi
            if ! [[ "$input_port" =~ ^[0-9]+$ ]]; then
                echo "‚ùå Invalid port number. Try again."
                continue
            fi
            if [[ -n "$(get_port_info "$input_port")" ]]; then
                echo "‚ùå Port $input_port appears to be in use. Choose another."
                continue
            fi
            HOST_PORT="$input_port"
            break
        done
        export HOST_PORT
    fi
    
    echo "üê≥ Starting containers..."
    if docker compose -f "$STACK_FILE" up -d; then
        echo "‚úÖ Stack started successfully!"
        echo "üåê Website: http://localhost:${HOST_PORT:-80}"
        echo "üîß phpMyAdmin: http://localhost:${PMA_PORT:-8081}"
        echo "üìä Database: localhost:${MYSQL_PORT:-3306}"
    else
        echo "‚ùå Failed to start stack"
        exit 1
    fi
}

# Function to stop stack
stop_stack() {
    # Get list of running compose projects
    local running_projects=$(docker ps --format 'table {{.Names}}' | grep -E '^[^-]+-[^-]+-[0-9]+$' | sed 's/-[^-]*-[0-9]*$//' | sort -u)
    
    if [[ -z "$running_projects" ]]; then
        echo "‚ÑπÔ∏è  No 20i stacks appear to be running"
        return 0
    fi
    
    echo "üõë Running 20i stacks:"
    echo "$running_projects" | nl
    echo
    
    read -p "Enter project number to stop (or 'a' for all): " choice
    
    if [[ "$choice" == "a" ]]; then
        echo "üõë Stopping all 20i stacks..."
        echo "$running_projects" | while read project; do
            if [[ -n "$project" ]]; then
                echo "Stopping $project..."
                COMPOSE_PROJECT_NAME="$project" docker compose -f "$STACK_FILE" down
            fi
        done
    else
        local project=$(echo "$running_projects" | sed -n "${choice}p")
        if [[ -n "$project" ]]; then
            echo "üõë Stopping stack: $project"
            COMPOSE_PROJECT_NAME="$project" docker compose -f "$STACK_FILE" down
            echo "‚úÖ Stack stopped: $project"
        else
            echo "‚ùå Invalid selection"
            exit 1
        fi
    fi
}

# Function to restart the current project's stack
restart_stack() {
    local PROJECT_DIR="$(pwd)"
    local PROJECT_NAME="$(basename "$PROJECT_DIR")"
    local SAFE_PROJECT_NAME="$(sanitize_project_name "$PROJECT_NAME")"

    echo "üîÅ Restarting 20i stack for project: $PROJECT_NAME"
    if [[ "$SAFE_PROJECT_NAME" != "$PROJECT_NAME" ]]; then
        echo "üìõ Normalized project name: $SAFE_PROJECT_NAME"
    fi

    # Check if the project has running containers
    if [[ -n "$(COMPOSE_PROJECT_NAME="$SAFE_PROJECT_NAME" docker compose -f "$STACK_FILE" ps -q 2>/dev/null)" ]]; then
        echo "‚ôªÔ∏è  Project appears to be running ‚Äî restarting containers..."
        COMPOSE_PROJECT_NAME="$SAFE_PROJECT_NAME" docker compose -f "$STACK_FILE" restart && echo "‚úÖ Restarted: $SAFE_PROJECT_NAME" || echo "‚ùå Restart failed"
    else
        echo "‚¨áÔ∏è  Project not running ‚Äî starting stack..."
        COMPOSE_PROJECT_NAME="$SAFE_PROJECT_NAME" docker compose -f "$STACK_FILE" up -d && echo "‚úÖ Started: $SAFE_PROJECT_NAME" || echo "‚ùå Start failed"
    fi
}

# Function to view status
view_status() {
    echo "üìä 20i Stack Status"
    echo "=================="
    echo
    echo "üê≥ All running containers:"
    docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | head -20
    echo
    echo "üìà Docker Compose projects:"
    docker ps --format 'table {{.Names}}' | grep -E '^[^-]+-[^-]+-[0-9]+$' | sed 's/-[^-]*-[0-9]*$//' | sort -u | nl
}

# Function to view logs
view_logs() {
    # Get list of running compose projects
    local running_projects=$(docker ps --format 'table {{.Names}}' | grep -E '^[^-]+-[^-]+-[0-9]+$' | sed 's/-[^-]*-[0-9]*$//' | sort -u)
    
    if [[ -z "$running_projects" ]]; then
        echo "‚ÑπÔ∏è  No 20i stacks appear to be running"
        return 0
    fi
    
    echo "üìã Running 20i stacks:"
    echo "$running_projects" | nl
    echo
    
    read -p "Enter project number to view logs: " choice
    
    local project=$(echo "$running_projects" | sed -n "${choice}p")
    if [[ -n "$project" ]]; then
        echo "üìã Viewing logs for: $project (Press Ctrl+C to stop)"
        COMPOSE_PROJECT_NAME="$project" docker compose -f "$STACK_FILE" logs -f
    else
        echo "‚ùå Invalid selection"
        exit 1
    fi
}

# Main execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    show_menu
fi
